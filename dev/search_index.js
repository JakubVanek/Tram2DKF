var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Tram2DKF","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Tram2DKF]","category":"page"},{"location":"reference/#Tram2DKF.EARTH_GRAVITY","page":"Reference","title":"Tram2DKF.EARTH_GRAVITY","text":"Earth gravitational acceleration, in m/s^2.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Tram2DKF.Accelerate","page":"Reference","title":"Tram2DKF.Accelerate","text":"Accelerate{NumT}\n\nThe tram should accelerate from its current speed to a new to_speed at a given acceleration.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.AccelerateState","page":"Reference","title":"Tram2DKF.AccelerateState","text":"AccelerateState{NumT}\n\nGenerate linearly ramped speed profile:\n\nat from_time the speed is from_speed\nat to_time the speed is to_speed\nacceleration is provided for convenience; it has the correct sign.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.ActiveSpeedProfileSegment","page":"Reference","title":"Tram2DKF.ActiveSpeedProfileSegment","text":"ActiveSpeedProfileSegment\n\nGenerates speed profile information for its specific segment.\n\nInterface\n\ndrive(segment::ActiveSpeedProfileSegment, time, position, speed, acceleration)::Union{TrajectoryDrive, Nothing}\n\nReturns the speed and acceleration at the given point on the speed profile. The position and time values are not relative wrt. the segment start, they are relative to the start of the entire journey.\n\nThe method needs to return nothing when this segment has ended.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.ActiveTrackSegment","page":"Reference","title":"Tram2DKF.ActiveTrackSegment","text":"ActiveTrackSegment\n\nGenerates curvature information for a specific segment of a track.\n\nInterface\n\ncurvature(segment::ActiveTrackSegment, position)::Union{TrackCurvature, Nothing}\n\nReturns the local curvature at position metres from track origin. The position value is not relative wrt. the segment start.\n\nThe method needs to return nothing when position is after the end of the track segment. However, it should return zero position when the position is before the start of the segment.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.BacktrackingLineSearch","page":"Reference","title":"Tram2DKF.BacktrackingLineSearch","text":"BacktrackingLineSearch{T <: Real}\n\nOptimize step length by iteratively shortening the step and checking if the Armijo condition holds.\n\nThe Armijo condition holds if the function has decreased enough compared to its derivative at the origin point.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.BacktrackingLineSearch-Tuple{Any, Any, Any}","page":"Reference","title":"Tram2DKF.BacktrackingLineSearch","text":"(bls::BacktrackingLineSearch)(V, x0, xstep0)\n\nOptimize step length via backtracking line search.\n\nThe function will find such a step to satisfy the Armijo condition when minimizing function V in the direction xstep0 when coming from point x0.\n\nThe new step vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.CartesianCA","page":"Reference","title":"Tram2DKF.CartesianCA","text":"CartesianCA # cartesian, constant acceleration\n\nRepresents an accelerating point mass. Velocity and acceleration are parameterized in cartesian coordinates.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... X speed\nx[4] ... Y speed\nx[5] ... X acceleration\nx[6] ... Y acceleration\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.CartesianCTRV","page":"Reference","title":"Tram2DKF.CartesianCTRV","text":"CartesianCTRV # cartesian, constant turn rate, constant velocity\n\nRepresents an rotating rigid body moving at a constant speed magnitude. Velocity is parameterized in cartesian coordinates and is continuously rotating.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... X speed\nx[4] ... Y speed\nx[5] ... yaw rate\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.CartesianCV","page":"Reference","title":"Tram2DKF.CartesianCV","text":"CartesianCV # cartesian, constant velocity\n\nRepresents an point mass moving at a constant speed. Velocity is parameterized in cartesian coordinates.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... X speed\nx[4] ... Y speed\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.CompositeMeasurement","page":"Reference","title":"Tram2DKF.CompositeMeasurement","text":"CompositeMeasurement\n\nGlues multiple independent measurements models into one measurement vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.CompositeMeasurement-Tuple{Any, Any}","page":"Reference","title":"Tram2DKF.CompositeMeasurement","text":"(msr::CompositeMeasurement)(x, u)\n\nEvaluate specified sub-measurements and concatenate their results into one large measurement vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.ConstantSpeed","page":"Reference","title":"Tram2DKF.ConstantSpeed","text":"ConstantSpeed{NumT}\n\nThe tram should move at a constant speed until it travels a given distance.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.ConstantSpeedState","page":"Reference","title":"Tram2DKF.ConstantSpeedState","text":"ConstantSpeedState{NumT}\n\nGenerate a constant speed profile until the to_point time mark.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.ContinuousTime","page":"Reference","title":"Tram2DKF.ContinuousTime","text":"ContinuousTime\n\nMarker indicating that the StateEquation operates in continuous time.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.DiscreteTime","page":"Reference","title":"Tram2DKF.DiscreteTime","text":"DiscreteTime\n\nMarker indicating that the StateEquation operates in discrete time.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.DiscretizedStateEquation","page":"Reference","title":"Tram2DKF.DiscretizedStateEquation","text":"DiscretizedStateEquation{SubmodelT <: StateEquation{ContinuousTime}, DiscretizationMethodT, TimeT}\n\nHelper object that wraps a continuous-time system and behaves like a discrete-time system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.ExtendedKalmanFilter","page":"Reference","title":"Tram2DKF.ExtendedKalmanFilter","text":"Extended Kalman filter\n\nThe EKF allows you to estimate the states of a nonlinear dynamical system under white Gaussian noise.\n\nEKF deals with the nonlinearities by linearizing the system at the current state estimate and then effectively applying the linear Kalman filter on that.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.Gaussian","page":"Reference","title":"Tram2DKF.Gaussian","text":"Gaussian{MeanT,CovT} <: UncertainValue\n\nRepresents a multidimensional normally distributed random variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.Gaussian-Tuple{Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.Gaussian","text":"Gaussian(g::UncertainValue)\n\nCreate a moment-matched Gaussian random variable for the given random variable g.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.IteratedExtendedKalmanFilter","page":"Reference","title":"Tram2DKF.IteratedExtendedKalmanFilter","text":"IteratedExtendedKalmanFilter{StepSizeControlT, StepNormT <: Real}\n\nThe IEKF allows you to estimate the states of a nonlinear dynamical system under white Gaussian noise.\n\nCompared to the classical EKF, the IEKF may work better for systems with strongly nonlinear measurement functions. This is because the IEKF actually finds the maximum aposteriori estimate when combining the state estimate with measurements.\n\nThe IEKF was implemented based on the article https://ieeexplore.ieee.org/document/10705771 . This article also illustrates that the IEKF is equivalent to a Gauss-Newton iteration that maximizes some criterion. The GN method is then extended to include step-size control to speed up convergence.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.KalmanFilter","page":"Reference","title":"Tram2DKF.KalmanFilter","text":"KalmanFilter\n\nAlgorithm for fusing measurements from multiple sensors and for estimating a state of a system whose state is measured.\n\nInterface\n\nforward_step(kf::KalmanFilter,\n             model::StateEquation{DiscreteTime},\n             prev_state::UncertainValue,\n             input,\n             process_noise::UncertainValue)::UncertainValue\n\nEstimate the state of model at the next time step.\n\nThe system is assumed to be in state prev_state with the specified input applied over the entire sampling period. Additionally, there is an unknown random disturbance described by process_noise.\n\nReturn the Gaussian belief about the state at the next time step.\n\nThis represents the classic Kalman \"time step\" / \"forward step\".\n\ndata_step(kf::KalmanFilter,\n          model::StateEquation{DiscreteTime},\n          prior::UncertainValue,\n          input,\n          observation::UncertainValue)::UncertainValue\n\nCorrect the current model state estimate prior using the observation.\n\nThe system is assumed to be in state prior with the specified input applied over the current sampling period.\n\nReturn the updated Gaussian belief about the state at the current time step.\n\nThis represents the classic Kalman \"data step\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.KalmanSmoother","page":"Reference","title":"Tram2DKF.KalmanSmoother","text":"KalmanSmoother\n\nExtension of KalmanFilter that supports smoothing (propagation of information back in time).\n\nInterface\n\nbackward_step(kf::KalmanFilter,\n              model::StateEquation{DiscreteTime},\n              current_posterior::UncertainValue,\n              next_prior::UncertainValue,\n              next_smoothed::UncertainValue)::UncertainValue\n\nSmooth the state of model at the current time step.\n\nThis represents the classic Rauch-Tung-Striebel smoothing algorithm that allows you to propagate information back in time. Given:\n\nthe estimate of state at time k given data up to time k (current_posterior),\nthe estimate of state at time k+1 given data up to time k (next_prior),\nthe estimate of state at time k+1 given data up to time l > k (next_smoothed),\n\nthe algorithm gives you an estimate at time k based on data up to time l > k.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.LTIMeasurementEquation","page":"Reference","title":"Tram2DKF.LTIMeasurementEquation","text":"LTIMeasurementEquation\n\nLinear time-invariant measurement model.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.LTIStateEquation","page":"Reference","title":"Tram2DKF.LTIStateEquation","text":"LTIStateEquation{T <: Time}\n\nLinear time-invariant state-space model.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.LinearKalmanFilter","page":"Reference","title":"Tram2DKF.LinearKalmanFilter","text":"LinearKalmanFilter\n\nThe LKF allows you to optimally estimate states of linear dynamical systems under white Gaussian noise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.MeasurementEquation","page":"Reference","title":"Tram2DKF.MeasurementEquation","text":"MeasurementEquation\n\nModel of a system state measurement.\n\nThe model is represented as an explicit function. Implicit measurement equations are not supported.\n\nInterface\n\nUsers can expect values of this type to have the following methods:\n\ny = (eq::MeasurementEquation)(x, u)\n\nPredict the measurement value based on the current state and return it as a vector.\n\nninputs(eq::StateEquation)\n\nExpected length of the control vector u.\n\nnstates(eq::StateEquation)\n\nExpected length of the state vector x.\n\nnoutputs(eq::StateEquation)\n\nExpected length of the measurement vector y.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.PolarCA","page":"Reference","title":"Tram2DKF.PolarCA","text":"PolarCA # polar, constant acceleration\n\nRepresents an accelerating point mass. Velocity is parameterized in polar coordinates; acceleration is assumed to only act in the forward direction.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... forward velocity\nx[4] ... forward acceleration\nx[5] ... heading\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.PolarCCA","page":"Reference","title":"Tram2DKF.PolarCCA","text":"PolarCCA # polar, constant curvature, constant acceleration\n\nRepresents an accelerating rigid body moving along a circular curve. Velocity is parameterized in polar coordinates; acceleration is assumed to only act in the forward direction.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... forward velocity\nx[4] ... forward acceleration\nx[5] ... heading\nx[6] ... track curvature\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.PolarCTRA","page":"Reference","title":"Tram2DKF.PolarCTRA","text":"PolarCTRA # polar, constant turn rate, constant acceleration\n\nRepresents an accelerating 2D rigid body moving along a clothoidal path. Velocity is parameterized in polar coordinates; acceleration is assumed to only act in the forward direction.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... forward velocity\nx[4] ... forward acceleration\nx[5] ... heading\nx[6] ... yaw rate\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.PolarCTRV","page":"Reference","title":"Tram2DKF.PolarCTRV","text":"PolarCTRV # polar, constant turn rate, constant velocity\n\nRepresents a 2D rigid body moving along a circular path along a constant speed. Velocity is parameterized in polar coordinates.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... forward velocity\nx[4] ... heading\nx[5] ... yaw rate\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.PolarCV","page":"Reference","title":"Tram2DKF.PolarCV","text":"PolarCV # polar, constant velocity\n\nRepresents a point mass moving at a constant velocity. Velocity is parameterized in polar coordinates.\n\nState vector layout\n\nx[1] ... X position\nx[2] ... Y position\nx[3] ... forward velocity\nx[4] ... heading\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.SpeedProfileSegment","page":"Reference","title":"Tram2DKF.SpeedProfileSegment","text":"SpeedProfileSegment\n\nSpecifies a part of a tram speed profile.\n\nInterface\n\nactivate(segment::SpeedProfileSegment, time, position, speed, acceleration)::ActiveSpeedProfileSegment\n\nReturns a description of the segment starting from a given tram motion state.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.SqrtGaussian","page":"Reference","title":"Tram2DKF.SqrtGaussian","text":"SqrtGaussian\n\nRepresents a multidimensional normally distributed random variable.\n\nCompared to Gaussian, this struct represents the covariance in a LLᵀ factorized form. Some Kalman filter implementations can exploit this to be more numerically stable.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.SqrtGaussian-Tuple{Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.SqrtGaussian","text":"Gaussian(g::UncertainValue)\n\nCreate a moment-matched Gaussian random variable for the given random variable g.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.StateEquation","page":"Reference","title":"Tram2DKF.StateEquation","text":"StateEquation{T <: Time}\n\nState-space dynamics model for an abstract system.\n\nThe model is represented by a first-order explicit vector ODE. DAE models are not supported.\n\nWhether the system is evolving in continuous or discrete time is determined by the T type argument. See DiscreteTime and ContinuousTime.\n\nInterface\n\nUsers can expect values of this type to have the following methods:\n\n(eq::StateEquation)(x, u)\n\nAdvance the state of the system:\n\ncontinuous-time systems return the derivative of the state at the current time\ndiscrete-time systems return the new state at the next time instant\n\nDependence on time is not explicitly modelled. If needed, the time can be obtained by introducing an additional state with derivative equal to 1.\n\nninputs(eq::StateEquation)\n\nExpected length of the control vector u.\n\nnstates(eq::StateEquation)\n\nExpected length of the state vector x.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.Stop","page":"Reference","title":"Tram2DKF.Stop","text":"Stop{NumT}\n\nThe tram should stand still for duration seconds.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.StopState","page":"Reference","title":"Tram2DKF.StopState","text":"StopState{NumT}\n\nGenerate zero speed until the end_at time mark.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.StraightTrack","page":"Reference","title":"Tram2DKF.StraightTrack","text":"StraightTrack{NumT}\n\nDescribes a distance metres long segment of a straight track (i.e. zero curvature).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.StraightTrackState","page":"Reference","title":"Tram2DKF.StraightTrackState","text":"StraightTrackState{NumT}\n\nGenerates zero curvature between from_point and to_point track positions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.Time","page":"Reference","title":"Tram2DKF.Time","text":"Time\n\nMarker type for discriminating between continuous-time and discrete-time models. Typically one of DiscreteTime and ContinuousTime.\n\nSee also StateEquation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.TrackCurvature","page":"Reference","title":"Tram2DKF.TrackCurvature","text":"TrackCurvature{NumT}\n\nRepresents the local geometry of a tram track.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.TrackSegment","page":"Reference","title":"Tram2DKF.TrackSegment","text":"TrackSegment\n\nSpecifies a part of a tram track geometry.\n\nInterface\n\nactivate(segment::TrackSegment, position)::ActiveTrackSegment\n\nReturns a description of the segment given its starting position in metres.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.TrackTurn","page":"Reference","title":"Tram2DKF.TrackTurn","text":"TrackTurn{NumT <: Real}\n\nDescribes a track curve, optionally including clothoid transition segments.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.TrackTurnState","page":"Reference","title":"Tram2DKF.TrackTurnState","text":"TrackTurnState\n\nPrecomputed trapezoidal curvature profile for a track turn.\n\nmax_curvature is the maximum curvature encountered.\nbetween transition_in_start and arc_start the curvature will be linearly increased\nbetween arc_start and transition_out_start the curvature will be constant (max_curvature)\nbetween transition_out_start and turn_end the curvature will be linearly decreased\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.TrajectoryDrive","page":"Reference","title":"Tram2DKF.TrajectoryDrive","text":"TrajectoryDrive{NumT}\n\nRepresents the local shape of the speed profile.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.UncertainValue","page":"Reference","title":"Tram2DKF.UncertainValue","text":"UncertainValue\n\nRepresents a randomly distributed variable with a well-defined mean and covariance.\n\nInterface\n\nmean(variable::UncertainValue)::Vector{<:Real}\n\nReturn the expected value of the random variable.\n\ncovariance(variable::UncertainValue)::Matrix{<:Real}\n\nReturn the covariance (second central moment) of the random variable.\n\npdf(variable::UncertainValue, value::Vector{<:Real})::Real\n\nEvaluate the probability density function at the given point.\n\nlogpdf(variable::UncertainValue, value::Vector{<:Real})::Real\n\nEvaluate the logarithm of the probability density function at the given point. This function can be more numerically stable than pdf() when small probabilities are involved (e.g. tails of a Gaussian).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Tram2DKF.Euler-NTuple{4, Any}","page":"Reference","title":"Tram2DKF.Euler","text":"Euler(f,x,u,dt)\n\nRun a single step of the Euler discretization method.\n\nReturn the state at which the system specified by the ODE f will be after dt seconds if the current state is x and control is u.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.IdentityStepping-Tuple{Any, Any, Any}","page":"Reference","title":"Tram2DKF.IdentityStepping","text":"IdentityStepping(V, x0, xstep0)\n\nNoop step size control: pass through the initial step size xstep0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.RK4-NTuple{4, Any}","page":"Reference","title":"Tram2DKF.RK4","text":"RK4(f,x,u,dt)\n\nRun a single step of the Runge-Kutta order 4 discretization method.\n\nReturn the state at which the system specified by the ODE f will be after dt seconds if the current state is x and control is u.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.backward_step-Tuple{LinearKalmanFilter, LTIStateEquation{DiscreteTime}, Tram2DKF.UncertainValue, Tram2DKF.UncertainValue, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.backward_step","text":"backward_step(::LinearKalmanFilter,\n              model::LTIStateEquation{DiscreteTime},\n              current_posterior::UncertainValue,\n              next_prior::UncertainValue,\n              next_smoothed::UncertainValue)\n\nPerform a smoothing step of a linear Rauch-Tung-Striebel smoother.\n\nThis allows you to propagate information from new measurements back in time and make the estimates of past states less noisy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.covariance-Tuple{Gaussian}","page":"Reference","title":"Tram2DKF.covariance","text":"covariance(g::Gaussian)\n\nReturn the covariance of the Gaussian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.covariance-Tuple{SqrtGaussian}","page":"Reference","title":"Tram2DKF.covariance","text":"covariance(g::SqrtGaussian)\n\nReturn the covariance of the Gaussian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.data_step-Tuple{ExtendedKalmanFilter, MeasurementEquation, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.data_step","text":"data_step(::ExtendedKalmanFilter,\n          g::MeasurementEquation,\n          prior::UncertainValue,\n          input,\n          observation::UncertainValue)\n\nPerform a data step of an extended Kalman filter.\n\nThis allows you to reduce the undertainty of a state estimate by incorporating new information from a state measurement.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.data_step-Tuple{IteratedExtendedKalmanFilter, MeasurementEquation, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.data_step","text":"data_step(iekf::IteratedExtendedKalmanFilter,\n          g::MeasurementEquation,\n          prior::UncertainValue,\n          input,\n          observation::UncertainValue)\n\nPerform a data step of an iterated extended Kalman filter.\n\nThis allows you to reduce the undertainty of a state estimate by incorporating new information from a state measurement.\n\nThis method actually computes the maximum aposteriori estimate of the state. Uncertainty propagation is handled by linearizing the system around this MAP estimate and then propagating the Gaussians just like the linear KF does.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.data_step-Tuple{LinearKalmanFilter, LTIMeasurementEquation, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.data_step","text":"data_step(::LinearKalmanFilter,\n          model::LTIMeasurementEquation,\n          prior::UncertainValue,\n          input,\n          observation::UncertainValue)\n\nPerform a data step of a linear Kalman filter.\n\nThis allows you to reduce the undertainty of a state estimate by incorporating new information from a linear state measurement.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.direct_forward_step-Tuple{LTIStateEquation{DiscreteTime}, SqrtGaussian, Any, SqrtGaussian}","page":"Reference","title":"Tram2DKF.direct_forward_step","text":"direct_forward_step(\n    model::LTIStateEquation{DiscreteTime},\n    prev_state::SqrtGaussian,\n    new_state,\n    process_noise::SqrtGaussian)\n\nCompute the covariance of a state estimate at time k+1 given data up to time k. Then attach it to a precomputed mean new_state and return it as a new belief.\n\nCompared to the direct_forward_step above, this method uses the QR factorization to compute the final covariance. This may be more numerically stable.\n\nFor details about the math, see T. M. Chin, „Square-root formulas for Kalman filter, information filter, and RTS smoother: Links via boomerang prediction residual\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.direct_forward_step-Tuple{LTIStateEquation{DiscreteTime}, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.direct_forward_step","text":"direct_forward_step(\n    model::LTIStateEquation{DiscreteTime},\n    prev_state::UncertainValue,\n    new_state,\n    process_noise::UncertainValue)\n\nCompute the covariance of a state estimate at time k+1 given data up to time k. Then attach it to a precomputed mean new_state and return it as a new belief.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.discretize","page":"Reference","title":"Tram2DKF.discretize","text":"discretize(model::StateEquation{ContinuousTime}, method, sampling_time, subsamples::Int = 1)\n\nDiscretize the given model using the discretization method with given sampling_time.\n\nAdditionally, each sampling_time interval can be internally split into subsamples sub-intervals over which will the discretization method` be repeatedly invoked.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Tram2DKF.dlerp-NTuple{4, Any}","page":"Reference","title":"Tram2DKF.dlerp","text":"dlerp(x0, y0, x1, y1)\n\nCalculate the slope of a line going through points (x0, y0) and (x1, y1).\n\nThis function is the derivative of dlerp with respect to the xq argument.\n\nSee also dlerp.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.forward_step-Tuple{ExtendedKalmanFilter, StateEquation{DiscreteTime}, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.forward_step","text":"forward_step(::ExtendedKalmanFilter,\n             f::StateEquation{DiscreteTime},\n             prev_state::UncertainValue,\n             input,\n             process_noise::UncertainValue)\n\nPerform a time step of an extended Kalman filter.\n\nThis will estimate the state of model at the next time step given the belief of prev_state and knowledge of input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.forward_step-Tuple{IteratedExtendedKalmanFilter, StateEquation{DiscreteTime}, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.forward_step","text":"forward_step(::IteratedExtendedKalmanFilter,\n             f::StateEquation{DiscreteTime},\n             prev_state::UncertainValue,\n             input,\n             process_noise::UncertainValue)\n\nPerform a time step of an iterated extended Kalman filter.\n\nThis will estimate the state of model at the next time step given the belief of prev_state and knowledge of input.\n\nGiven that the IEKF does not iterate the time update, this is fully equivalent to the EKF forward step.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.forward_step-Tuple{LinearKalmanFilter, LTIStateEquation{DiscreteTime}, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.forward_step","text":"forward_step(::LinearKalmanFilter,\n             model::LTIStateEquation{DiscreteTime},\n             prev_state::UncertainValue,\n             input,\n             process_noise::UncertainValue)\n\nPerform a time step of a linear Kalman filter.\n\nThis will estimate the state of model at the next time step given the belief of prev_state and knowledge of input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.iekf_finalize-Tuple{MeasurementEquation, SqrtGaussian, Any, Any, SqrtGaussian}","page":"Reference","title":"Tram2DKF.iekf_finalize","text":"iekf_finalize(\n    g::MeasurementEquation,\n    prior::SqrtGaussian,\n    map_estimate,\n    input,\n    observation::SqrtGaussian)\n\nCompute the final state estimate covariance around the MAP estimate.\n\nThis variant uses square-root-filtering algoritms for increased accuracy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.iekf_finalize-Tuple{MeasurementEquation, Tram2DKF.UncertainValue, Any, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.iekf_finalize","text":"iekf_finalize(\n    g::MeasurementEquation,\n    prior::UncertainValue,\n    map_estimate,\n    input,\n    observation::UncertainValue)\n\nCompute the final state estimate covariance around the MAP estimate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.iekf_gauss_newton_step-Tuple{MeasurementEquation, Tram2DKF.UncertainValue, Any, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.iekf_gauss_newton_step","text":"iekf_gauss_newton_step(\n    g::MeasurementEquation,\n    prior::UncertainValue,\n    current_est,\n    input,\n    observation::UncertainValue)\n\nPerform one iteration of the internal Gauss-Newton-like method.\n\nThis method does not perform step size control. Instead, the unscaled step is returned.\n\nSee https://ieeexplore.ieee.org/document/10705771 for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.innovation_data_step-Tuple{LTIMeasurementEquation, SqrtGaussian, Any, SqrtGaussian}","page":"Reference","title":"Tram2DKF.innovation_data_step","text":"innovation_data_step(\n    model::LTIMeasurementEquation,\n    prior::SqrtGaussian,\n    innovation,\n    observation::SqrtGaussian)\n\nCompute a corrected state estimate given a new measurement.\n\nThis method is intended as a reusable piece of data_step. It takes in a innovation, which is the difference between the actual measured value and the value predicted by the state estimate prior. Thanks to this, it can be, in principle, applied to nonlinear models as well.\n\nCompared to the innovation_data_step above, this method uses the QR factorization to compute the final covariance. This may be more numerically stable.\n\nFor details about the math, see T. M. Chin, „Square-root formulas for Kalman filter, information filter, and RTS smoother: Links via boomerang prediction residual\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.innovation_data_step-Tuple{LTIMeasurementEquation, Tram2DKF.UncertainValue, Any, Tram2DKF.UncertainValue}","page":"Reference","title":"Tram2DKF.innovation_data_step","text":"innovation_data_step(\n    model::LTIMeasurementEquation,\n    prior::UncertainValue,\n    innovation,\n    observation::UncertainValue)\n\nCompute a corrected state estimate given a new measurement.\n\nThis method is intended as a reusable piece of data_step. It takes in a innovation, which is the difference between the actual measured value and the value predicted by the state estimate prior. Thanks to this, it can be, in principle, applied to nonlinear models as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.lerp-NTuple{5, Any}","page":"Reference","title":"Tram2DKF.lerp","text":"lerp(x0, y0, x1, y1, xq)\n\nPerform linear interpolation between two points.\n\nThe interpolation line is specified using the points (x0, y0) and (x1, y1). The function then returns the y-coordinate of the point with x-coordinate equal to xq.\n\nSee also dlerp.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.linearize-Tuple{MeasurementEquation, Any, Any}","page":"Reference","title":"Tram2DKF.linearize","text":"linearize(g::MeasurementEquation, x, u)\n\nLinearize the given nonlinear measurement model g at the operating point specified by state x and control u.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.linearize-Union{Tuple{TimeT}, Tuple{StateEquation{TimeT}, Any, Any}} where TimeT<:Tram2DKF.Time","page":"Reference","title":"Tram2DKF.linearize","text":"linearize(f::StateEquation{TimeT}, x, u) where {TimeT <: Time}\n\nLinearize the given nonlinear dynamic model f at the operating point specified by state x and control u.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.logpdf-Tuple{Gaussian, Any}","page":"Reference","title":"Tram2DKF.logpdf","text":"logpdf(g::Gaussian, value)\n\nEvaluate the logarithm of the probability density function at the given point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.logpdf-Tuple{SqrtGaussian, Any}","page":"Reference","title":"Tram2DKF.logpdf","text":"logpdf(g::SqrtGaussian, value)\n\nEvaluate the logarithm of the probability density function at the given point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.mean-Tuple{Gaussian}","page":"Reference","title":"Tram2DKF.mean","text":"mean(g::Gaussian)\n\nReturn the mean of the Gaussian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.mean-Tuple{SqrtGaussian}","page":"Reference","title":"Tram2DKF.mean","text":"mean(g::SqrtGaussian)\n\nReturn the mean of the Gaussian.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.pdf-Tuple{Gaussian, Any}","page":"Reference","title":"Tram2DKF.pdf","text":"pdf(g::Gaussian, value)\n\nEvaluate the probability density function at the given point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.pdf-Tuple{SqrtGaussian, Any}","page":"Reference","title":"Tram2DKF.pdf","text":"pdf(g::SqrtGaussian, value)\n\nEvaluate the probability density function at the given point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.simulate_accelerometer-Tuple{Any, Any}","page":"Reference","title":"Tram2DKF.simulate_accelerometer","text":"simulate_accelerometer(states, wn_std)\n\nSimulate 3-axis accelerometer measurements for the trajectory defined by the states sequence.\n\nThe accelerometer is assumed to be aligned with the vehicle body (X forward, Y left, Z up). Additionally, the measurements are corrupted by a white Gaussian noise with standard deviation equal to wn_std.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.simulate_gnss-Tuple{Any, Any, Any}","page":"Reference","title":"Tram2DKF.simulate_gnss","text":"simulate_gnss(states, altitude, cov_matrix)\n\nSimulate GNSS measurements for the trajectory defined by the states sequence.\n\nThe GNSS will return directly the X and Y state components in metres. Additionally, it will return the specified altitude. Finally, all the components are corrupted by a white Gaussian noise with cov_matrix covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.simulate_gyro-Tuple{Any, Any}","page":"Reference","title":"Tram2DKF.simulate_gyro","text":"simulate_gyro(states, wn_std)\n\nSimulate 3-axis gyro measurements for the trajectory defined by the states sequence.\n\nThe gyro is assumed to be aligned with the vehicle body (X forward, Y left, Z up). Additionally, the measurements are corrupted by a white Gaussian noise with standard deviation equal to wn_std.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Tram2DKF.simulate_odometry-Tuple{Any, Any}","page":"Reference","title":"Tram2DKF.simulate_odometry","text":"simulate_odometry(states, granularity)\n\nSimulate odometry measurements for the trajectory defined by the states sequence.\n\nThe odometer is assumed to be counting teeth on a wheel encoder. Thus, a position quantization is simulated. However, no slip is simulated.\n\nThe returned distances are still in metres.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Tram2DKF","category":"page"},{"location":"#Tram2DKF","page":"Home","title":"Tram2DKF","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A set of utilities for testing tram localization algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can be roughly split in three parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Framework for defining linear and nonlinear state space models\nImplementation of Kalman filters:\nLinear Kalman filter\nExtended Kalman filter\nIterated Extended Kalman filter\nGenerator of tram trajectories based on simple track geometry description","category":"page"},{"location":"#State-space-models","page":"Home","title":"State space models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To estimate the state of something using Kalman filters, you need to have a model of it. This package accepts linear and nonlinear explicit state-space models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nonlinear models are defined by creating a new structure that implements a StateEquation{Time} abstract type. The Time parameter determines the kind of the system: either DiscreteTime or ContinuousTime.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You could define a continuous-time model this way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Tram2DKF\nimport Tram2DKF.ninputs, Tram2DKF.noutputs, Tram2DKF.nstates\n\n# define new struct\nstruct FancyIntegrator <: StateEquation{ContinuousTime} end\n\n# compute state derivative: just the input\n(::FancyIntegrator)(x, u) = [u[1]]\n\n# add marker functions\nninputs(::FancyIntegrator) = 1\nnstates(::FancyIntegrator) = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then discretize such a model into a discrete-time model. Alternatively, you may directly define a struct subclassing StateEquation{DiscreteTime}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Linear models are represented using LTIStateEquation and LTIMeasurementEquation types. These structs directly accept the state-space matrices as their fields.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may also linearize a nonlinear model in some operating point into a linear model.","category":"page"},{"location":"#Kalman-filtering","page":"Home","title":"Kalman filtering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kalman filters, in a nutshell, allow you to fuse information from multiple sources. This allows you to reduce the effect of measurement noise on your estimates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package currently implements a LinearKalmanFilter, an ExtendedKalmanFilter and an IteratedExtendedKalmanFilter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The structs themselves carry only the parameters of the respective algorithms. To invoke the filters, you can use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the forward_step function for the time update step (= prediction of new state),\nthe data_step function for the data update step (= fusion of sensor measurements),\nthe backward_step function for a backward smoothing step (= smoothing of old states based on new measurements).","category":"page"},{"location":"","page":"Home","title":"Home","text":"These filters assume that measurements and states are Gaussian random variables. To represent such variables, the Gaussian and SqrtGaussian types is used. The latter is used to implement more numerically stable updates. Additionally, there is a UncertainValue abstract type that unifies the two representations behind two methods: mean and covariance.","category":"page"},{"location":"#Tram-trajectories","page":"Home","title":"Tram trajectories","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ultimate goal of this package is to be useful in developing tram localization algorithms. To compare different algorithms, it is necessary to obtain some dataset on which they could be tested. This is somewhat nontrivial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package allows you to generate synthetic data based on a simple description. The description is composed of two parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Description of the tram track. This basically determines where the track turns straight track segments are, and what are their parameters.\nDescription of the tram speed profile. This determines when the tram accelerates or decelerates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is illustrated by a simple example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Tram2DKF\nusing LinearAlgebra\n\n# Define track profile\ntrack = [\n    StraightTrack(distance=100.0),\n    TrackTurn(angle=deg2rad(+90), radius=20.0, transition_curve_length=0.0),\n    StraightTrack(distance=100.0),\n]\n\n# Define speed profile\ntrip = [\n    Stop(duration=1.0),\n    Accelerate(to_speed=10.0, acceleration=1.0),\n    ConstantSpeed(speed=5.0, distance=50.0),\n    Stop(duration=10.0),\n]\n\n# Generate ground truth data\nstates = render_trip(track, trip, Ts, 10)\n# ^ `states` is a vector of state vectors at different times\n\n# Simulate sensor measurements corrupted by noise\ngyro = simulate_gyro(states, 0.02)\nacc  = simulate_accelerometer(states, 0.1)\nodo  = simulate_odometry(states, 0.01)\ngnss = simulate_gnss(states, 200, I(3))","category":"page"},{"location":"#Demo-scripts","page":"Home","title":"Demo scripts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are three example scripts available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"scripts/plot_curved_track.jl shows how to generate samples of the track position without concern for any tram dynamics.\nscripts/plot_speed_profile.jl shows how to generate trajectories of trams when considering changes in speed.\nscripts/estimation_test.jl is an all-in-one example:\nfirst, the test data is generated\nthen, a model is defined (or, rather, a predefined PolarCTRA model is reused)\nfinally, a Kalman filter is run to try to undo the effect of noise in measurements","category":"page"}]
}
